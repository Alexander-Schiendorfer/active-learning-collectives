package utilities.parameters;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Class that is responsible for accessing simulation parameters. Has to be initialized before first use!
 */
public class SimulationParameters {

	/**
	 * For logging purposes.
	 */
	private final static Logger LOG = LogManager.getLogger(SimulationParameters.class);

	/**
	 * Holds the used {@link SimulationParametersProvider} that provides access to the simulation parameters.
	 */
	protected static SimulationParametersProvider myParamProvider;

	/**
	 * Indicates whether or not the {@link SimulationParameters} are currently in the modify state (which can be entered
	 * by the {@link SimulationParametersModifier}). Retrieving parameters in the modify state leads to an
	 * {@link IllegalStateException}.
	 */
	protected static boolean modifyingSimulationParametersState = false;

	/**
	 * Holds the (first) used default value of a parameter. Used to check if a parameter request with another default
	 * value takes place.
	 */
	private static Map<String, Object> savedDefaultValues = new HashMap<String, Object>();

	/**
	 * A set of {@link IParameterChangeListener}s to inform if the {@link Parameters} have changed.
	 */
	private final static Set<IParameterChangeListener> parameterChangeListeners = Collections.synchronizedSet(new HashSet<IParameterChangeListener>());

	/**
	 * Initializes this class with all {@link Parameters} as generated by the given
	 * {@link ISimulationParametersInitializer}s. <br>
	 * <br>
	 *
	 * Be aware that if this method is called several times (after first calling the destroy method), the old
	 * {@link Parameters} are gone. All registered {@link IParameterChangeListener}s are then informed that the
	 * {@link Parameters} are new ones.
	 *
	 * @param parameterInitializers
	 *            the concrete {@link ISimulationParametersInitializer}s that initialize the
	 *            {@link SimulationParametersProvider}
	 * @throwing {@link IllegalStateException} if there is already a {@link SimulationParametersProvider} which has not
	 *           been destroyed
	 */
	public static void init(ISimulationParametersInitializer... parameterInitializers) {

		// just for info: the old simulation parameters provider is now replaced by a new one
		if (SimulationParameters.myParamProvider != null) {
			throw SimulationParameters.LOG
					.throwing(new IllegalStateException(
							"There was already an old SimulationParametersProvider present. You cannot initialize a new SimulationParametersProvider without explicitly destroying the old one first!"));
		}

		// then we are going to initialize from a fresh base
		SimulationParameters.initOrAdopt(parameterInitializers);
	}

	/**
	 * Initializes this class with all {@link Parameters} as generated by the given
	 * {@link ISimulationParametersInitializer}s.<br>
	 * This method will adopt parameters if there are any already.<br>
	 * If you don't want that, call {@link SimulationParameters#init(ISimulationParametersInitializer...)} or destroy
	 * existing Parameters first.<br>
	 *
	 * Be aware that if this method is called several times (after first calling the destroy method), the old
	 * {@link Parameters} are gone. All registered {@link IParameterChangeListener}s are then informed that the
	 * {@link Parameters} are new ones.
	 *
	 * @param parameterInitializers
	 *            the concrete {@link ISimulationParametersInitializer}s that initialize the
	 *            {@link SimulationParametersProvider}
	 */
	public static void initOrAdopt(ISimulationParametersInitializer... parameterInitializers) {

		// either create a new parameters object or use the old one instead
		Parameters parameters = null;
		if (SimulationParameters.myParamProvider != null) {
			parameters = SimulationParameters.myParamProvider.getParameters();
			SimulationParameters.LOG.info("Adopted existing simulation parameters.");
		} else {
			parameters = new Parameters();
		}

		// merge all parameters as returned by the given simulation parameter initializers into one object
		for (ISimulationParametersInitializer parameterInitializer : parameterInitializers) {
			parameters.addAllParameters(parameterInitializer.initializeSimulationParameters());
		}

		// initialize the simulation parameters provider
		SimulationParameters.myParamProvider = new SimulationParametersProvider(parameters);
		SimulationParameters.myParamProvider.getParameters();

		// refresh parameters of all available parameter listeners
		synchronized (SimulationParameters.parameterChangeListeners) {
			for (IParameterChangeListener parameterChangeListener : SimulationParameters.parameterChangeListeners) {
				SimulationParameters.LOG.debug("Refreshing parameter listener '" + parameterChangeListener.getClass().getSimpleName() + "'.");
				parameterChangeListener.refreshParameters();
			}
		}
	}

	/**
	 * Destroys the old {@link SimulationParametersProvider}. Calls to get a parameter value for a given parameter name
	 * are no longer possible and result in an {@link NullPointerException}. <br>
	 * <br>
	 *
	 * Must be explicitly called before setting a new {@link SimulationParametersProvider} to prevent parameter
	 * replacements that are made by accident. A new initialization of an {@link SimulationParametersProvider} without
	 * destroying the old one results in an {@link IllegalStateException}.
	 */
	public static void destroy() {
		SimulationParameters.myParamProvider = null;
		// reset the map that holds all collected default values
		SimulationParameters.savedDefaultValues.clear();
	}

	/**
	 * Checks if a given parameter is present.
	 *
	 * @param parameterName
	 *            the name of the parameter to check for its presence.
	 * @return <code>true</code> if the parameter is present and has a non-null value, <code>false</code> otherwise
	 */
	public static boolean exists(String parameterName) {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.exists(parameterName);
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Double} values.
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @return a {@link Double} representing the value of the parameter
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static Double getDoubleParameter(String parameterName) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getDoubleParameter(parameterName);
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Integer} values.
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @return an {@link Integer} representing the value of the parameter
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static Integer getIntParameter(String parameterName) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getIntParameter(parameterName);
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Long} values.
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @return a {@link Long} representing the value of the parameter
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static Long getLongParameter(String parameterName) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getLongParameter(parameterName);
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Boolean} values.
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @return a {@link Boolean} representing the value of the parameter
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static Boolean getBoolean(String parameterName) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getBoolean(parameterName);
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link String} values.
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @return a {@link String} representing the value of the parameter
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static String getString(String parameterName) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getString(parameterName);
	}

	/**
	 * Gets the value of the parameter identified by its name. Returns an array of {@link String} values. The value of
	 * the parameter must be a {@link String}, separating the single {@link String} elements by a ";".
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @return an array of {@link String}s representing the value of the parameter
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static String[] getStrings(String parameterName) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getStrings(parameterName);
	}

	/**
	 * Gets the value of the parameter identified by its name. Returns an array of {@link Double} values. The value of
	 * the parameter must be a {@link String}, separating the single {@link Double} elements by a ";".
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @return an array of {@link Double}s representing the value of the parameter
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static Double[] getDoubles(String parameterName) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getDoubles(parameterName);
	}

	/**
	 * Gets an instance of an Object whose class is identified by the parameter. Returns {@link Object} values.
	 *
	 * @param parameterName
	 *            the name of the parameter that contains the class name
	 * @return an {@link Object} instance of the class identified by the parameter
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static Object getObject(String parameterName) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getObject(parameterName);
	}

	/**
	 * Gets an instance of an Object whose class is identified by the parameter and calls the constructor as identified
	 * by the provided classes and instance parameters. Returns {@link Object} values.
	 *
	 * @param parameterName
	 *            the name of the parameter that contains the class name
	 * @param classes
	 *            the classes of the parameters given to the constructor
	 * @param instanceParameters
	 *            the values of the parameters given to the constructor
	 * @return an {@link Object} instance of the class identified by the parameter and initialized with the constructor
	 *         the fits the given classes
	 * @throws ParameterNotAvailableException
	 *             if the parameter wasn't found
	 */
	public static Object getObject(String parameterName, Class<?>[] classes, Object[] instanceParameters) throws ParameterNotAvailableException {
		SimulationParameters.checkSimulationParametersState();
		return SimulationParameters.myParamProvider.getObject(parameterName, classes, instanceParameters);
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Double} values. If there is no parameter
	 * with the given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return a {@link Double} representing the value of the parameter or a default value if no parameter with the
	 *         given name exists
	 */
	public static Double getDoubleParameter(String parameterName, Double defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getDoubleParameter(parameterName);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			Double savedDefaultValue = (Double) SimulationParameters.savedDefaultValues.get(parameterName);
			if (!savedDefaultValue.equals(defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Integer} values. If there is no parameter
	 * with the given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return an {@link Integer} representing the value of the parameter or a default value if no parameter with the
	 *         given name exists
	 */
	public static Integer getIntParameter(String parameterName, Integer defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getIntParameter(parameterName);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			Integer savedDefaultValue = (Integer) SimulationParameters.savedDefaultValues.get(parameterName);
			if (!savedDefaultValue.equals(defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Long} values. If there is no parameter with
	 * the given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return an {@link Long} representing the value of the parameter or a default value if no parameter with the given
	 *         name exists
	 */
	public static Long getLongParameter(String parameterName, Long defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getLongParameter(parameterName);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			Long savedDefaultValue = (Long) SimulationParameters.savedDefaultValues.get(parameterName);
			if (!savedDefaultValue.equals(defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Boolean} values. If there is no parameter
	 * with the given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return an {@link Boolean} representing the value of the parameter or a default value if no parameter with the
	 *         given name exists
	 */
	public static Boolean getBoolean(String parameterName, Boolean defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getBoolean(parameterName);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			Boolean savedDefaultValue = (Boolean) SimulationParameters.savedDefaultValues.get(parameterName);
			if (!savedDefaultValue.equals(defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link String} values. If there is no parameter
	 * with the given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return an {@link String} representing the value of the parameter or a default value if no parameter with the
	 *         given name exists
	 */
	public static String getString(String parameterName, String defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getString(parameterName);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			String savedDefaultValue = (String) SimulationParameters.savedDefaultValues.get(parameterName);
			if (!savedDefaultValue.equals(defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/**
	 * Gets the value of the parameter identified by its name. Returns an array of {@link String} values. The value of
	 * the parameter must be a {@link String}, separating the single {@link String} elements by a ";". If there is no
	 * parameter with the given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return an array of {@link String}s representing the value of the parameter or a default value if no parameter
	 *         with the given name exists
	 */
	public static String[] getStrings(String parameterName, String[] defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getStrings(parameterName);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			String[] savedDefaultValue = (String[]) SimulationParameters.savedDefaultValues.get(parameterName);
			if (!Arrays.equals(savedDefaultValue, defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/**
	 * Gets the value of the parameter identified by its name. Returns an array of {@link Double} values. The value of
	 * the parameter must be a {@link String}, separating the single {@link Double} elements by a ";". If there is no
	 * parameter with the given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return an array of {@link Double}s representing the value of the parameter or a default value if no parameter
	 *         with the given name exists
	 */
	public static Double[] getDoubles(String parameterName, Double[] defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getDoubles(parameterName);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			Double[] savedDefaultValue = (Double[]) SimulationParameters.savedDefaultValues.get(parameterName);
			if (!Arrays.equals(savedDefaultValue, defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/**
	 * Gets the value of the parameter identified by its name. Returns an array of {@link Double} values. The value of
	 * the parameter must be a {@link String}, separating the single {@link Double} elements by a ";". If there is no
	 * parameter with the given name specified, an array of the given size initialized with the given default values is
	 * used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified. The whole array is
	 *            initialized with this default value.
	 * @param size
	 *            the size of the array initialized with the default value
	 * @return an array of {@link Double}s representing the value of the parameter or a default value if no parameter
	 *         with the given name exists
	 */
	public static Double[] getDoubles(String parameterName, Double defaultVal, int size) {
		Double[] defaultVals = new Double[size];
		Arrays.fill(defaultVals, defaultVal);

		return SimulationParameters.getDoubles(parameterName, defaultVals);
	}

	/**
	 * Gets the value of a parameter identified by its name. Returns {@link Object} values. If there is no parameter
	 * with the given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return an {@link Object} representing the value of the parameter or a default value if no parameter with the
	 *         given name exists
	 */
	public static Object getObject(String parameterName, Object defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getObject(parameterName);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			Object savedDefaultValue = SimulationParameters.savedDefaultValues.get(parameterName);
			if (!savedDefaultValue.equals(defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/**
	 * Gets an instance of an Object whose class is identified by the parameter and calls the constructor as identified
	 * by the provided classes and instance parameters. Returns {@link Object} values. If there is no parameter with the
	 * given name specified, the given default value is used. <br>
	 * <br>
	 *
	 * Note that if there was previously already a call that needed to return a default value for this parameter name
	 * and this time there is another default value given (different from the first one), the default value of the first
	 * call is returned!
	 *
	 * @param parameterName
	 *            the name of the parameter that contains the class name
	 * @param classes
	 *            the classes of the parameters given to the constructor
	 * @param instanceParameters
	 *            the values of the parameters given to the constructor
	 * @param defaultVal
	 *            the default value to use if there is no parameter with the given name specified
	 * @return an {@link Object} instance of the class identified by the parameter and initialized with the constructor
	 *         the fits the given classes or a default value if no parameter with the given name exists
	 */
	public static Object getObject(String parameterName, Class<?>[] classes, Object[] instanceParameters, Object defaultVal) {
		SimulationParameters.checkSimulationParametersState();

		if (SimulationParameters.exists(parameterName)) {
			return SimulationParameters.myParamProvider.getObject(parameterName, classes, instanceParameters);
		}

		if (SimulationParameters.savedDefaultValues.containsKey(parameterName)) {
			// we already used a default value for this parameter -- check if they are the same and return the saved one
			Object savedDefaultValue = SimulationParameters.savedDefaultValues.get(parameterName);
			if (!savedDefaultValue.equals(defaultVal)) {
				SimulationParameters.warnWrongDefaultValueMessage(parameterName, defaultVal, savedDefaultValue);
			}
			return savedDefaultValue;
		} else {
			// we did not already use a default value for this parameter -- save this one
			SimulationParameters.savedDefaultValues.put(parameterName, defaultVal);
		}

		SimulationParameters.warnDefaultValueMessage(parameterName, defaultVal);
		return defaultVal;
	}

	/* ****************************
	 * Parameter Change Listeners *
	 ******************************/

	/**
	 * Adds a new {@link IParameterChangeListener} to the set of {@link IParameterChangeListener}s that are informed if
	 * the {@link Parameters}s have changed.
	 *
	 * @param parameterChangeListener
	 *            the {@link IParameterChangeListener} to add
	 */
	public static void addParameterChangeListener(IParameterChangeListener parameterChangeListener) {
		SimulationParameters.LOG.debug("Adding parameter listener '" + parameterChangeListener.getClass().getSimpleName() + "'.");
		SimulationParameters.parameterChangeListeners.add(parameterChangeListener);
	}

	/* *************
	 * State check *
	 ***************/

	/**
	 * Checks whether the {@link SimulationParameters} are currently in the modify state and if so throws an
	 * {@link IllegalStateException}.
	 */
	private static void checkSimulationParametersState() {
		if (SimulationParameters.modifyingSimulationParametersState) {
			SimulationParameters.LOG
					.throwing(new IllegalStateException(
							"SimulationParameters are currently in the modify state. Retrieval of parameters is thus currently discouraged until this state is left (see SimulationParametersModifier)."));
		}
	}

	/* *********
	 * Logging *
	 ***********/

	/**
	 * Logs a warn message if the parameter does not exist and the default value has to be used.
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param defaultVal
	 *            the default value of the parameter
	 */
	private static void warnDefaultValueMessage(String parameterName, Object defaultVal) {
		String defaultValAsString;
		if (defaultVal == null) {
			defaultValAsString = "null";
		} else if (defaultVal.getClass().isArray()) {
			defaultValAsString = Arrays.toString((Object[]) defaultVal);
		} else {
			defaultValAsString = defaultVal.toString();
		}
		SimulationParameters.LOG.warn("Parameter '" + parameterName + "' does not exist. Using default value '" + defaultValAsString + "'.");
	}

	/**
	 * Logs an error message if the parameter does not exist and the given default value is not the same as in a
	 * previous parameter request.
	 *
	 * @param parameterName
	 *            the name of the parameter
	 * @param givenDefaultValue
	 *            the default value of the parameter
	 * @param savedDefaultValue
	 *            the saved default value of the parameter
	 */
	private static void warnWrongDefaultValueMessage(String parameterName, Object givenDefaultValue, Object savedDefaultValue) {
		String givenDefaultValAsString = givenDefaultValue.toString();
		String savedDefaultValueAsString = savedDefaultValue.toString();
		if (givenDefaultValue.getClass().isArray()) {
			givenDefaultValAsString = Arrays.toString((Object[]) givenDefaultValue);
			savedDefaultValueAsString = Arrays.toString((Object[]) savedDefaultValue);
		}
		SimulationParameters.LOG.error("Parameter '" + parameterName + "' does not exist. The given default value '" + givenDefaultValAsString
				+ "' is, however, not the same as the default value that was used before and that will be further used ('" + savedDefaultValueAsString + "').");
	}
}